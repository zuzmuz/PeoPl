
* The Language Overview
  This is a {:docs/small_overview.norg:}[small overview], a more {:docs/overview.norg:}[comprehensive overview] is not complete

* The Manifesto
  Check the {:docs/themanifesto.norg:}[the manifesto], AI helped me write it

* Why

  A low level pipeline oriented programming language

** Why pipeline oriented
   Pipeline-oriented programming isn't just a syntactic preference, it's a fundamental design choice that enables three critical guarantees:
*** Safety
    Pipeline orientation creates a linear, predictable control flow that dramatically simplifies complex compiler analysis.
    - simple type inference
    - lifetime and ownership clarity
    - resource management

    Traditional imperative code where resources, ownership, and control flow are scattered across multiple statements, makes analysis exponentially more complex.

*** Performance
    Pipeline orientation naturally encourages pure functions and data immutability, unlocking aggressive compiler optimizations.
    - memory layout optimization
    - memory release and reuse
    - automatic parallelization

*** Readability
    This might be subjective,
    Pipeline orientation mirrors human thought processes and data transformation workflows
    @code peopl
    // Read left-to-right, top-to-bottom like prose
    user_input
    |> sanitize()
    |> parse()
    |> validate()
    |> process()
    |> format_response()

    // vs. traditional nested calls (read inside-out)
    format_response(process(validate(parse(sanitize(user_input)))))
    @end

** Why low level
   I love control and performance. I always loved functional programming languages but hated their syntax or the lack of low level features.
   Manual memory management does not need to be this complicated, and sometime the cost of a garbage collector is much bigger than the reward.

** So
   PeoPl is pipeline oriented at its core. Pipeline oriented programming is not necessarily functional, it can be performed in OOP through object method chaining.
   However, PeoPl provides the clever syntax to enable powerful features that do not sacrifice performance for expressibility

* Installation
  You can't install it right now

** Build it
   Make sure you have swift installed. Compile it with spm.

* What's available
  - A tree sitter grammar for syntax highlighting in your editor (needs manual configuration)
  - An lsp (that doesn't work)
  - Compiler with LLVM as backend (still WIP)
