#+title: Small Overview
#+author: Zaher Hamadeh

* Table Of Content :toc:
- [[#what-is-this][What is this]]
- [[#what-is-peopl][What is PeoPl]]
- [[#a-peopl-file][A PeoPl File]]
- [[#main][Main]]
- [[#definitions][Definitions]]
- [[#qualified-identifiers][Qualified Identifiers]]
- [[#expressions][Expressions]]
  - [[#literals][Literals]]
  - [[#unary-and-binary-expressions][Unary and Binary Expressions]]
  - [[#pipeline-expressions][Pipeline Expressions]]
  - [[#input-capturing-and-pattern-matching][Input Capturing and Pattern Matching]]
- [[#function-definitions][Function Definitions]]
  - [[#input][Input]]
  - [[#function-examples][Function Examples]]
  - [[#function-overloading][Function Overloading]]
- [[#type-definitions][Type Definitions]]
  - [[#records-and-tuples][Records and Tuples]]
  - [[#choices-enums-tagged-unions][Choices, Enums, Tagged Unions]]
  - [[#type-aliases][Type Aliases]]
- [[#call-expressions][Call Expressions]]
- [[#comments][Comments]]

* What is this
  This is a small introduction to PeoPl.
  Knowledge of programming languages and concepts is assumed.
  To get a more in-depth tour over PeoPl's features and specifications, read the {:overview.norg:}[comprehensive overview].

* What is PeoPl
  *PeoPl* is a /Pipeline Expression Oriented Programming Language/.

  It is a general-purpose, compiled, statically typed programming language with:
  - Expressive pipeline-oriented programming style 
  - Powerful type system for domain modeling
  - Low-level control
  - Expressive generics system

  Programs are constructed as pipelines of operations, where each operation receives data, transforms it, and passes it forward.

* A PeoPl File
  A PeoPl source file ends with the file extension =.ppl=.
  It contains top-level definitions.
  Definitions define compile-time constructs: values, expressions, types, and functions.

* Main
  If running in single-file mode, one definition must exist in the file, and it is the main function.

  #+begin_src peopl
  main: 0
  #+end_src

  This is the simplest PeoPl file.
  Here =main= is defined as the value 0.
  Running this file will call `main`, and the program will then terminate with the value of =main=, which is 0.

  =main= should be, or should return, an 8-bit integer.

  =main= can be a function that runs at runtime and calculates its output value.
  This is how functions are defined:

  #+begin_src peopl
  main: func [] -> Int {
  0
  }
  #+end_src

* Definitions
  A PeoPl file is basically a list of definitions. We covered the main definition; here's the format of custom definitions:

  #+begin_src peopl
  qualifiedIdentifier OptionalType: expression
  #+end_src

  Note: There's no apostrophe after the identifier.

* Qualified Identifiers
  A qualified identifier is a scoped identifier. Scoping an identifier with a namespace or prefix is performed using the =\= symbol:

  #+begin_src peopl
  aBasicIdentifier
  A\Scoped\Identifier
  #+end_src

  This is used for namespacing.

* Expressions
  Everything in PeoPl is an expression that produces a value.

  Expressions can be:
  - Constant literals
  - Arithmetic expressions (unary or binary operations)
  - Call expressions (function calls)
  - Function definitions
  - Type specifiers (type definitions)
  - Pipeline expressions
  - Pattern matching expressions

** Literals

   #+begin_src peopl
   // The empty tuple, the unit type
   nothing

   // Boolean literals
   true
   false

   // Number literals
   // Integers
   42
   690
   0xFF468A                // hex integer literal
   0xABCD_1234_AFDE_0987   // hex also supports _
   0b1010_1010_1110        // binary
   0o1727432               // octal
   0o777_123_123           // all integer number formats support _

   // Floats
   3.1415

   // String literal
   "hi"
   #+end_src

** Unary and Binary Expressions
   This is a list of all operators:
   - Multiplicative operators: ~*~, ~/~, ~%~  (they overflow)
   - Additive operators: ~+~, ~-~ (they also overflow)
   - Comparative operators: ~=~, ~>~, ~>=~, ~<~, ~<=~
   - Logic operators: ~and~, ~or~, ~not~

   This is a list of legal operations in PeoPl:
   - Unary: =operator operand= - if the unary expression has a valid input, it will apply the operation
   - Binary: =lhs operator rhs=

   PeoPl allows any operator to be used as a unary operator. For example, =*3= represents an expression that multiplies its input by 3.

** Pipeline Expressions
   The core feature of PeoPl is pipeline-oriented programming using the =|>= operator:

   #+begin_src peopl
   // Basic piping
   "hello world" |> reverse()  // Returns "dlrow olleh"

   // Method-like syntax is also supported
   "hello world".reverse()     // Equivalent

   // Multi-step pipelines
   42 |> toString() |> reverse()  // Returns "24"

   // Complex transformations
   "1,2,3,4,5"
   |> split(separator: ",")
   |> map(transform: parseInt)
   |> filter {|$x| x > 2}
   |> sum()                      // Returns 12
   #+end_src

** Input Capturing and Pattern Matching
   Capture pipeline inputs using the vertical bar notation =|$name|=:

   #+begin_src peopl
   // Input capturing
   12321
   |> toString()
   |> |$value| value = value.reverse()  // Returns true (palindrome check)

   // Pattern matching with branching
   value
   |>
   |0| "Zero"
   |1| "One"
   |$n if n < 0| "Negative"
   |$n if n % 2 = 0| "Even"
   |_| "Other"
   #+end_src

* Function Definitions
  Functions in PeoPl are pure expressions.

  To define a function:

  #+begin_src peopl
  qualifiedIdentifier: func (OptionalInputType)[arg1' ArgType1, arg2' ArgType2] -> OutputType {
  // function body
  }
  #+end_src

** Input
   PeoPl doesn't have classes, but you can emulate methods using functions with inputs.
   The input is a special argument, passed implicitly to the function body like =self= or =this= in other programming languages.
   A function doesn't need to have an input. This means the function is top-level or static.

** Function Examples

   #+begin_src peopl
   // Function with no input (static function)
   thisReturns42: func [] -> Int {
   42
   }

   // Function with input
   square: (Int)[] -> Int {
   |$in| in * in
   }

   // Function with arguments
   add: [a' Int, b' Int] -> Int {
   a + b
   }

   // Calling functions
   5.square()      // returns 25
   5 |> square()   // equivalent
   add(a: 2, b: 3) // returns 5
   #+end_src

** Function Overloading
   Function overloading is supported on the name of the arguments, (not the types).
   The argument list are part of the signature of the function.
   Dissallowing overloading on types simplifies type inference.

* Type Definitions

** Records and Tuples
   Product types for structured data:

   #+begin_src peopl
   // Tuples (positional access)
   Point: [Float, Float]
   coordinates: Point(3.14, 2.71)
   x: coordinates._0  // 3.14

   // Records (named access)
   Person: [name' String, age' Int]
   person: Person(name: "Alice", age: 30)
   name: person.name  // "Alice"
   #+end_src

** Choices, Enums, Tagged Unions
   Sum types for representing alternatives:

   #+begin_src peopl
   // Basic enums
   Color: choice [red', green', blue', yellow']

   // Tagged unions with associated values
   Shape: choice [
   circle' [radius' Float],
   rectangle' [width' Float, height' Float]
   ]

   // Pattern matching on choice types
   processShape: func (Shape)[] -> Float {
   |circle: (radius: $r)| PI * r * r
   |rectangle: (width: $w, height: $h)| w * h
   }
   #+end_src

** Type Aliases
   Create meaningful names for existing types:

   #+begin_src peopl
   UserId: Int
   Email: String
   Point2D: [x' Float, y' Float]
   #+end_src

   TypeAliases are distinct, and =Int= can be used as a =UserId= but a =UserId= can not be used as an =Int=

* Call Expressions
  Function calls are expressions that can run at compile time or runtime:

  #+begin_src peopl
  // Simple function call
  myFunction()

  // Function call with arguments
  add(a: 10, b: 5)

  // Pipelined function calls
  value |> transform() |> process()

  // Method-style calls
  "hello".reverse().toUpperCase()
  #+end_src

* Comments
  Start a comment with two forward slashes. Multiline comments are not supported:

  #+begin_src peopl
  // This is a comment
  main: func [] -> Int { // This is also a comment
      0
  }
  #+end_src
