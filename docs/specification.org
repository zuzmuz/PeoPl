#+TITLE: PeoPl Language Specification
#+AUTHOR: Zaher Hamadeh
#+DATE: May 21, 2025

* What is PeoPl

PeoPl is expression-oriented programming language built around the concept of data pipelines.
Inspired by functional programming paradigms and Unix shell philosophy,

Programs are constructed as pipelines of operations,
where each operation receives data, transforms it, and passes it forward.

** Design Principles
*** Expression Oriented
Everything in PeoPl is an expression that produces a value.
#+BEGIN_SRC peopl
"hello"                    // A string literal expression returning "hello"
42                         // An integer literal expression returning 42
2 + 3                      // A binary operation expression returning 5
#+END_SRC

*** Pipeline Centric
PeoPl models computation as data flowing through transformation nodes,
similar to Unix pipes but with structured data.
#+BEGIN_SRC peopl
// Piping a string through functions
"hello world" |> reverse()                // Returns "dlrow olleh"

// Method-like syntax is also supported
"hello world".reverse()                   // Returns "dlrow olleh"

// Multi-step pipelines are natural
42 |> toString() |> reverse()             // Returns "24"
42.toString().reverse()                   // Equivalent method syntax

// Complex transformations become readable pipelines
"1,2,3,4,5"
|> split(separator: ",")
|> map(transform: parseInt)
|> filter {|$x| x > 2}
|> sum()                                // Returns 12
#+END_SRC

Drawing inspiration from Unix pipes, functional programming's composition operators, and object methods,
PeoPl makes data flow the central mechanism of the language.
Each function in a pipeline takes the output of the previous function as its primary input,
with additional arguments.

PeoPl's expression-only design eliminates the statement/expression dichotomy found in many languages.

** Input Capturing in Pipelines

A distinctive feature of PeoPl is its ability to explicitly name and manipulate the pipeline input within transformation nodes. This is done using the input capture syntax with the vertical bar notation `|$name|`.

#+BEGIN_SRC peopl
// Input capturing using |$name| syntax
12321
|> toString()
|> |$value| value = value.reverse() // Returns true (palindrome check)
#+END_SRC

Input capturing provides explicit naming for pipeline data.

** Pattern Matching for Branching

PeoPl uses pattern matching as its primary branching mechanism. Pattern matching allows code to examine data structure and shape, decompose it, and execute different logic based on the patterns that match.

#+BEGIN_SRC peopl
// Basic pattern matching on values
value
|>
    |0| "Zero",
    |1| "One",
    |$n if n < 0| "Negative",
    |$n if n % 2 = 0| "Even",
    |_| "Other"
#+END_SRC

** Piping Complex Data Structures

PeoPl uses product types (tuples, records) to pass complex data structure

Records (objects with named fields) can be passed through pipelines and accessed directly within transformation nodes:

#+BEGIN_SRC peopl
// Piping a record
(width: 10, height: 5)
|> |$in| in.width * in.height  // Returns 50


// Piping a record and anonymous capture
(width: 10, height: 5)
|> |$| width * height  // Returns 50
#+END_SRC

** Tuples and Positional Data

Tuples (ordered collections of values) can be processed efficiently:

#+BEGIN_SRC peopl
// Piping a tuple through a transformation
(10, 5)
|> |$dimensions| dimensions.0 * dimensions.1  // Returns 50
#+END_SRC

** Nested Structures

PeoPl handles deeply nested data structures elegantly:

#+BEGIN_SRC peopl
// Processing nested data
(
  user: (name: "Abdulla", birthyear: 1934),
  role: "admin"
)
|> |$data| (
  username: data.user.name,
  age: 2025 - data.user.birthyear,
  canEdit: data.role = "admin"
)

// Nested pattern matching
(
  user: (name: "Abdulla", birthyear: 1934),
  role: "admin"
)
|> |(user: (name: "Hanine", birthyear: $year, role: $role)| "Hanin is born in $birthyear"
#+END_SRC
