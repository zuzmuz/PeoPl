* ğŸ›ï¸ Core Philosophy

  /The history of all hitherto existing programming languages is the history of struggle between those who control the machine and those who are controlled by it./

  Programming languages have long struggled with the tension between abstraction and control, safety and performance, simplicity and power.

  *PeoPl rejects these false dichotomies* and establishes clear principles that guide every design decision. These principles represent lessons learned from decades of programming language evolution and a commitment to empowering programmers rather than constraining them.


  > Programmers of all languages, unite! You have nothing to lose but your technical debt. ğŸš©


* I. ğŸ’ª Programmer Empowerment

** âš¡ The Dictatorship of the Programmer
   Programmers must have explicit control over program behavior. The language provides clear, direct mechanisms for expressing intent without hidden abstractions that obscure execution.

** ğŸ” No Hidden Conspiracy
   All language behaviors, transformations, and runtime actions are explicit and visible. Implicit conversions, hidden allocations, and magical transformations are **prohibited**.

   /What you write is what executes./

** ğŸ—¡ï¸ Arm the Programmer with Sharp Tools
   Powerful capabilities shall not be withheld from programmers. The language provides expressive, efficient tools even when they require expertise to use safely. We trust programmers to handle powerful abstractions responsibly.

* II. ğŸ¯ Design Priorities

** ğŸ“Š The Primary Hierarchy
   When design decisions conflict, prioritize in strict order:

   1. *Expressiveness* - The ability to clearly communicate programmer intent
   2. *Safety* - Prevention of undefined behavior and runtime errors
   3. *Efficiency* - Optimal resource utilization and performance

** âš–ï¸ Prohibited Trade-offs
   The following compromises are rejected:

*** ğŸš« /Never/ sacrifice /ergonomics/ for safety
    Safety must be achieved through good design, not by making the language difficult to use

*** ğŸ›¡ï¸ /Never/ sacrifice /safety/ for performance
    - Programs must be safe by default
    - No undefined behavior
    - No easy foot guns
    - Correct behavior takes precedence over raw speed

*** âš¡ /Never/ sacrifice /performance/ for ergonomics
    Language features must not intentionally produce inefficient code for the sake of convenience. Performance characteristics should be predictable and optimal

    > These 3 rules provide checks and balances between the 3 branches of PeoPl's core design principles. âš–ï¸

** ğŸŒ Accessibility Priorities
   For developer adoption and experience:

   - *Accessible* - Easy to learn and approach
   - *Discoverable* - Features and capabilities are findable
   - *Available* - Tooling and resources are readily accessible

* III. ğŸ”§ Technical Decisions

** ğŸ¤ The Compiler as Ally
   The compiler serves the programmer. Error messages are helpful, diagnostics are actionable, and the toolchain guides rather than obstructs development.

   - The grammar should stay simple with orthogonal concepts
   - The semantics can be progressively complex as long as the syntax is simple
   - This reduces cognitive load and parsing ambiguity

** ğŸ’ Be Opinionated
   The language makes principled decisions rather than trying to accommodate every possible approach. We choose:

   - Clarity over universality
   - Coherence over compatibility
   - Consistent design over backward compatibility

** ğŸ­ Things That are Different Should Look Different
   Different concepts should look different to avoid ambiguity.

** ğŸª Things That are Similar Should Look Similar
   There should not be drastically different ways to express similar concepts.

* IV. âš”ï¸ The Critique of Existing Systems

** ğŸ‘‘ The Inheritance Bourgeoisie
   /The ruling classes of object-oriented programming have imposed upon us a system where complex hierarchies obscure simple relationships./

   Inheritance is the opium of the programmer! It promises easy code reuse but delivers only tangled dependencies and brittle architectures that crumble under the weight of their own contradictions.

   **Inheritance is prohibited.** Composition, interfaces, and algebraic types provide superior abstraction mechanisms. Code reuse is achieved through explicit composition and generic programming.

** ğŸ—‘ï¸ The Garbage Collection Oligarchy
   The memory management elite have convinced the masses that automatic collection is liberation, when in truth it is the most insidious form of control. It leaves us powerless to predict when our systems will stumble under their invisible hand.

   *Automatic memory management is prohibited.* Memory allocation and deallocation remain under explicit programmer control through deterministic, predictable mechanisms.

* V. ğŸ¥… Goals
** ğŸ—¡ï¸ Separation of Data and Processing
   Provide a healty and clear divide between what represents data and what represents behavior.

** ğŸ›• Structure program behavior
   Programs are designed as a structured pipeline of nodes, where data flow is clear and predictable.
   Complex systems with concurency and reactivity becomes simpler to design and understand.

** ğŸ•Šï¸ Lightweight Type system
   Expressing a domain model should be light weight and simple, extensible and modifiable

* ğŸ“¢ Call to Action

  > /The functional programming bros have only interpreted computation in various ways; the point is to change it!/ ğŸ”„

** Status

   > Constitutional - These principles define the fundamental character of PeoPl
   > and should only be modified through careful consideration of their
   > implications for the entire language ecosystem. ğŸ“œ
